package functest

import (
	"math/rand"
	"testing"
	"time"

	"github.com/zclconf/go-cty/cty"
)

// FunctionPropertyTest represents the definition of a test run which
// attempts to find arguments generated by the given ArgsGen that fail to
// satisfy the given condition.
//
// The usual way to use this type is to use one of the various constructor
// functions that return FunctionPropertyTest objects and then pass the
// resulting object's `Run` method as the argument to `t.Run` in a normal Go
// test:
//
//     t.Run(
//         "add is commutative",
//         functest.TestCommutative(functest.GenNumbers, Add).Run,
//     )
type FunctionPropertyTest struct {
	// Rand is a random number generator to use. If this is nil,
	// the Run method will create its own and assign it here.

	// Set this to a non-nil value if you want to force a particular starting
	// seed in order to reproduce a particular set of randomly-chosen inputs,
	// or if you wish to force using a custom random source.
	Rand *rand.Rand

	// Arguments is an ArgsGen function that will be called to produce
	// randomly-chosen input arguments to pass to the Check function.
	Arguments ArgsGen

	// Check is the function which will be called to check each of the
	// sets of arguments produced by the ArgsGen function. It must return
	// true from all calls in order for the test to be considered successful.
	Check func(args []cty.Value) bool
}

// Test creates a simple FunctionPropertyTest that just tries to find arguments
// that make the given function return false.
//
// There are other functions with the "Test..." prefix which represent more
// specific common properties for functions. This is the general case that
// is really just a thin wrapper around the basic functionality of
// FunctionPropertyTest.
//
// Note that this function (and the other "Test..." functions only construct
// the test object, and don't actually run it. That's so you can potentially
// call other methods on the test to customize it before finally calling "Run".
func Test(args ArgsGen, f func(args []cty.Value) bool) *FunctionPropertyTest {
	return &FunctionPropertyTest{
		Arguments: args,
		Check:     f,
	}
}

// TestSuccessful creates a FunctionPropertyTest that tries to find evidence
// that the given function could fail for at least some of the sets of
// arguments in the range of the given ArgsGen.
//
// Because this function is generic over argument lists of any length, it
// requires a function which accepts its arguments as a single slice of values.
// The Call method of function.Function instances satisfies that signature.
//
// TestSuccessful will also indicate failure if the function returns a nil
// error but sets its result to cty.NilVal, because cty.NilVal is never a
// suitable return value for a successful function call.
func TestSuccessful(args ArgsGen, f func(args []cty.Value) (cty.Value, error)) *FunctionPropertyTest {
	check := func(args []cty.Value) bool {
		v, err := f(args)
		return err == nil && v != cty.NilVal
	}
	return &FunctionPropertyTest{
		Arguments: args,
		Check:     check,
	}
}

// TestSuccessfulType creates a FunctionPropertyTest that tries to find evidence
// that the given function could fail for at least some of the sets of
// arguments in the range of the given ArgsGen, or that it could succeed
// but generate a value that doesn't conform to the given type constraint.
//
// Because this function is generic over argument lists of any length, it
// requires a function which accepts its arguments as a single slice of values.
// The Call method of function.Function instances satisfies that signature.
func TestSuccessfulType(args ArgsGen, wantTy cty.Type, f func(args []cty.Value) (cty.Value, error)) *FunctionPropertyTest {
	check := func(args []cty.Value) bool {
		v, err := f(args)
		if err != nil {
			return false
		}
		errs := v.Type().TestConformance(wantTy)
		return len(errs) == 0
	}
	return &FunctionPropertyTest{
		Arguments: args,
		Check:     check,
	}
}

// TestError creates a FunctionPropertyTest that tries to find evidence
// that the given function could succeed for at least some of the sets of
// arguments in the range of the given ArgsGen.
//
// Because this function is generic over argument lists of any length, it
// requires a function which accepts its arguments as a single slice of values.
// The Call method of function.Function instances satisfies that signature.
func TestError(args ArgsGen, f func(args []cty.Value) (cty.Value, error)) *FunctionPropertyTest {
	check := func(args []cty.Value) bool {
		_, err := f(args)
		return err != nil
	}
	return &FunctionPropertyTest{
		Arguments: args,
		Check:     check,
	}
}

// TestIdempotent creates a FunctionPropertyTest that tries to find evidence
// that the given function isn't idempotent for all arguments in the range
// of the given ValueGen.
//
// This test helper only works for single-argument functions, because it
// passes the return value from one call into a second call and functions
// can return only one value. For more complicated scenarios you may need to
// construct a custom FunctionPropertyTest.
//
// TestIdempotent will also indicate failure for any input that causes the
// function to return an error. The ValueGen should be constrained to only
// produce valid arguments for the function.
func TestIdempotent(vals ValueGen, f func(arg cty.Value) (cty.Value, error)) *FunctionPropertyTest {
	// We test for idempotence by calling the function twice, with the
	// second call taking the return value from the first.
	args := GenFixedArgs(vals) // We always generate exactly one argument
	check := func(args []cty.Value) bool {
		first, err := f(args[0])
		if err != nil {
			return false
		}
		second, err := f(first)
		if err != nil {
			return false
		}
		return second.RawEquals(first)
	}
	return &FunctionPropertyTest{
		Arguments: args,
		Check:     check,
	}
}

// TestCommutative creates a FunctionPropertyTest that tries to find evidence
// that the given function isn't commutative for all pairs of arguments in the
// range of the given ValueGen.
//
// This test helper only works for two-argument functions, because it
// calls the given function twice to cover both permutations of the generated
// arguments. For more complicated scenarios you may need to construct a custom
// FunctionPropertyTest.
//
// TestCommutative will also indicate failure for any input that causes the
// function to return an error. The ValueGen should be constrained to only
// produce valid arguments for the function.
func TestCommutative(vals ValueGen, f func(a1, a2 cty.Value) (cty.Value, error)) *FunctionPropertyTest {
	// We test for the commutative property by calling the function twice, with
	// the second call taking the same arguments in the opposite order.
	args := GenFixedArgs(vals, vals) // We always generate exactly two arguments
	check := func(args []cty.Value) bool {
		first, err := f(args[0], args[1])
		if err != nil {
			return false
		}
		second, err := f(args[1], args[0])
		if err != nil {
			return false
		}
		return second.RawEquals(first)
	}
	return &FunctionPropertyTest{
		Arguments: args,
		Check:     check,
	}
}

// TestAssociative creates a FunctionPropertyTest that tries to find evidence
// that the given function isn't associative for all pairs of arguments in the
// range of the given ValueGen.
//
// This test helper only works for two-argument functions. For more complicated
// scenarios you may need to construct a custom FunctionPropertyTest.
//
// TestAssociative will also indicate failure for any input that causes the
// function to return an error. The ValueGen should be constrained to only
// produce valid arguments for the function.
func TestAssociative(vals ValueGen, f func(a1, a2 cty.Value) (cty.Value, error)) *FunctionPropertyTest {
	// We test for associativity by calling the function four times, with
	// each pair expected to return the same result.
	args := GenFixedArgs(vals, vals, vals) // We always generate exactly three arguments
	check := func(args []cty.Value) bool {
		a1, err := f(args[0], args[1])
		if err != nil {
			return false
		}
		a2, err := f(a1, args[2])
		if err != nil {
			return false
		}

		b1, err := f(args[1], args[2])
		if err != nil {
			return false
		}
		b2, err := f(args[0], b1)
		if err != nil {
			return false
		}

		return a2.RawEquals(b2)
	}
	return &FunctionPropertyTest{
		Arguments: args,
		Check:     check,
	}
}

// TestInverse creates a FunctionPropertyTest that tries to find evidence
// that the two given functions are not inverses for each other for all
// arguments in the range of the given ValueGen.
//
// This test helper only works for one-argument functions. It passes each
// generated value to the "forward" function, then passes that result to
// the "backward" function, and then requires that the final result match
// the originally-generated value.
//
// TestInverse will also indicate failure for any input that causes the
// function to return an error. The ValueGen should be constrained to only
// produce valid arguments for the function.
func TestInverse(vals ValueGen, forward, backward func(v cty.Value) (cty.Value, error)) *FunctionPropertyTest {
	args := GenFixedArgs(vals) // We always generate exactly one argument
	check := func(args []cty.Value) bool {
		a, err := forward(args[0])
		if err != nil {
			return false
		}
		b, err := backward(a)
		if err != nil {
			return false
		}
		return args[0].RawEquals(b)
	}
	return &FunctionPropertyTest{
		Arguments: args,
		Check:     check,
	}
}

// WithRand returns a copy of the receiver with the same definition aside from
// having a different random number generator.
//
// This is essentially the same as setting the Rand field in the reciever,
// but is here to allow convenient method chaining from the test constructor
// functions when defining property tests.
func (test FunctionPropertyTest) WithRand(rnd *rand.Rand) *FunctionPropertyTest {
	test.Rand = rnd
	return &test
}

// Run is a test helper for running the test process described by the
// receiver.
//
// This function calls Fail on the given t if any of the checks fail, and
// also generates test log lines describing the arguments passed to the
// check function in each failing case.
//
// This is a basic property testing harness which does a bare minimum
// generative testing operation, but if you are doing a lot of property-based
// testing, or if your function has complicated inputs that could benefit from
// techniques such as automatic shrinking, it may be better to use a full
// property-based testing library like "gopter", potentially with generators
// that wrap the ValueGen and ArgsGen types in this package.
// TestFunctionProperty is here mainly to avoid imposing a particular big
// testing library on dependents of cty.
//
// This function also generates compact representations of the arguments
// that will not be particularly readable for complex data structures. It
// would ideally use the debug printer for cty values from go-cty-debug, but
// we can't import that here without creating a circular dependency. If you
// use a third-party property-based testing helper instead, hopefully you can
// configure it to use pretty-printed values.
//
// If you see a failure for randomly-generated input, typically the next step
// is to copy the input into a suitable example-based unit test and reproduce
// the failure there, and then change the function under test so that it
// passes the test.
func (test *FunctionPropertyTest) Run(t *testing.T) {
	const checkCount = 1000 // Maybe we'll make this customizable later

	t.Helper()

	if test.Rand == nil {
		test.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))
	}

	failures := 0
	for i := 0; i < checkCount; i++ {
		args := test.Arguments(test.Rand)
		passed := test.Check(args)
		if !passed {
			t.Errorf("property not satisfied\nfailing arguments: %#v", args)
			failures++
		}
	}
	if pct := (failures * 100) / checkCount; pct > 0 {
		t.Logf("%d%% of the generated inputs failed", pct)
	} else if failures > 0 {
		// We're normally rounding down but it's confusing to say 0%
		// failed if more than one failed, so we have a special case for
		// small numbers of failures.
		t.Log("<1% of the generated inputs failed")
	}
}
